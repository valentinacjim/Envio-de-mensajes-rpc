/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "claves.h"
#include "claves_fun.h"
#include "sll.h"
pthread_mutex_t mimutex = PTHREAD_MUTEX_INITIALIZER;

struct List *lista;
int lista_creada = 0;

bool_t
server_init_1_svc(int *result, struct svc_req *rqstp)
{
	bool_t retval;
	pthread_mutex_lock(&mimutex);
	if (lista_creada){
			freeList(lista);
		}
	lista = newList();
	lista_creada = 1;
	pthread_mutex_unlock(&mimutex);
	*result = 0;
	
	
	retval = TRUE;
	
	return retval;
}

bool_t
server_set_value_1_svc(int key, char *value1, int value2, double value3, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	struct elemento new;
	retval = TRUE;
	pthread_mutex_lock(&mimutex);
	if (lista_creada == 0){
			*result = -1;
			return retval;
		}
	new.clave = key;
	strncpy(new.val1, value1, 256);
	new.val2 = value2;
	new.val3 = value3;
	if(search(lista, new.clave) == NULL){
		add(lista, new);
			*result = 0;
		}
		else{
			*result = -1;
			
		}
	pthread_mutex_unlock(&mimutex);
	return retval;
}

bool_t
server_get_value_1_svc(int key, respuesta *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;
	result->value1 = malloc(256);
	pthread_mutex_lock(&mimutex);
	if (lista_creada == 0){
		result->result = -1;
		return retval;
	}
	if (search(lista, key) != NULL){
		struct Node *e = search(lista, key);
		result->result = 0;
		//result->value1 = e->data.clave;
		strncpy(result->value1, e->data.val1, 256);
		result->value2 = e->data.val2;
		result->value3 = e->data.val3;
		// retval = TRUE;
		return retval;
	}
	pthread_mutex_unlock(&mimutex);
	result->result = -1;
	return retval;
}

bool_t
server_modify_value_1_svc(int key, char *value1, int value2, double value3, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;
	pthread_mutex_lock(&mimutex);
	if (lista_creada == 0){
			*result= -1;
			return retval;
		}
	if (search(lista, key) == NULL){
		*result = -1;
		return retval;
		}
	struct Node *e = search(lista, key);
	strncpy(e->data.val1, value1, 256);
	e->data.val2 = value2;
	e->data.val3 = value3;
	
	pthread_mutex_unlock(&mimutex);	
	*result = 0;
	return retval;
}

bool_t
server_delete_key_1_svc(int key, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	retval = TRUE;
	pthread_mutex_lock(&mimutex);	
	if (lista_creada == 0){
		*result = -1;
		return retval;
	}
	if (search(lista, key) == NULL){
		*result = -1;
		return retval;
	}
	removeNode(lista, key);
	pthread_mutex_unlock(&mimutex);
	*result = 0;
	// retval = TRUE;
	return retval;
}

bool_t
server_exist_1_svc(int key, int *result, struct svc_req *rqstp)
{
	bool_t retval;
	struct elemento new;
	retval = TRUE;
	
	pthread_mutex_lock(&mimutex);
	if (lista_creada == 0){
		*result = -1;
		return retval;
	}
	if (search(lista, key) == NULL){
		*result = 0;
		// retval = TRUE;
		return retval;
	}
	pthread_mutex_unlock(&mimutex);
	*result = 1;
		
	// retval = TRUE;
	return retval;
}

bool_t
server_copy_key_1_svc(int key1, int key2, int *result,  struct svc_req *rqstp)
{
	bool_t retval;
	struct elemento new;
	retval = TRUE;
	
	pthread_mutex_lock(&mimutex);
	if (lista_creada == 0){		
		*result = -1;
		return retval;
	}
	
	struct Node *e1 = search(lista, key1);
	if (e1 == NULL){
		*result = -1;
		return retval;
	}
		
	struct Node *e2 = search(lista, key2);

	if (e2 != NULL){
		strncpy(e2->data.val1, e1->data.val1, 256);
		e2->data.val2 = e1->data.val2;
		e2->data.val3 = e1->data.val3;
		*result = 0;
		// retval = TRUE;
		return retval;
	}
		
	new.clave = key2;
	strncpy(new.val1, e1->data.val1, 256);
	new.val2 = e1->data.val2;
	new.val3 = e1->data.val3;
	add(lista, new);
	pthread_mutex_unlock(&mimutex);
	*result = 0;
	// retval = TRUE;
	return retval;
}

int
claves_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
